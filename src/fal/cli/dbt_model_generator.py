import ast
import astor
import re
from typing import List
from pathlib import Path

from faldbt.parse import load_dbt_project_contract

SQL_MODEL_TEMPLATE = """
{{ config(materialized='ephemeral') }}
/*
FAL_GENERATED

Script dependencies:

__deps__

*/

SELECT * FROM {{ target.schema }}.{{ model.name }}
"""


def generate_python_dbt_models(project_dir: str):
    project_contract = load_dbt_project_contract(project_dir)
    python_paths = _find_python_files(project_contract.model_paths)

    for py_path in python_paths:
        sql_path = py_path.with_suffix(".sql")
        _check_path_safe_to_write(sql_path, py_path)

        with open(py_path) as file:
            module = ast.parse(file.read(), str(py_path), "exec")

        dbt_deps: str = _generate_dbt_dependencies(module)
        sql_contents = SQL_MODEL_TEMPLATE.replace("__deps__", dbt_deps)

        with open(sql_path, "w") as file:
            file.write(sql_contents)


def _check_path_safe_to_write(sql_path: Path, py_path: Path):
    if sql_path.exists():
        with open(sql_path, "r") as file:
            contents = file.read()
            if "FAL_GENERATED" not in contents:
                raise RuntimeError(
                    f"File '{sql_path}' not generated by fal would be overwritten by generated model of '{py_path}'. Please rename or remove."
                )


def _find_python_files(model_paths: List[str]) -> List[Path]:
    paths_lists = map(lambda d: list(Path(d).rglob("*.py")), model_paths)
    flat_paths = sum(paths_lists, [])
    flat_files = filter(lambda p: p.is_file(), flat_paths)
    return list(flat_files)


def _find_function_calls(module: ast.Module):
    return [node for node in ast.walk(module) if isinstance(node, ast.Call)]


def _find_dbt_function_calls(calls: List[ast.Call], func_name: str):
    """
    Analyze all function calls in the file to find the ones that call `func_name` with all literal arguments.
    We ignore a `ref(var)` but accept a `ref('model_name')`
    """
    func_calls = [
        call
        for call in calls
        if isinstance(call.func, ast.Name) and call.func.id == func_name
    ]

    return [
        call
        for call in func_calls
        if all(map(lambda arg: isinstance(arg, ast.Constant), call.args))
    ]


REF_RE = re.compile("ref\\([^)]*\\)")
SOURCE_RE = re.compile("source\\([^)]*\\)")


def _find_docstring_dbt_functions(module: ast.Module) -> List[str]:
    '''
    Simple regex analysis for docstring in top of the file. User can list dependencies one per line, but not multiline.
    Example:

    """
    A Python model with some docstring introduction.

    Dependencies:
    - ref('model')
    - source('some', 'table')
    """
    '''
    docstring = ast.get_docstring(module, True) or ""

    calls = []
    for line in docstring.splitlines():
        calls.extend(REF_RE.findall(line))
        calls.extend(SOURCE_RE.findall(line))

    return calls


def _generate_dbt_dependencies(module: ast.Module) -> str:
    """
    Search for dbt function uses and return them as found wrapped in Jinja braces.
    We do not modify them to let dbt decide if they make sense.
    """

    function_calls = _find_function_calls(module)

    dbt_ast_calls: List[ast.Call] = []
    dbt_ast_calls.extend(_find_dbt_function_calls(function_calls, "ref"))
    dbt_ast_calls.extend(_find_dbt_function_calls(function_calls, "source"))

    # Convert ast.Calls back to source code
    dbt_function_calls = list(map(astor.to_source, dbt_ast_calls))
    docstring_dbt_functions = _find_docstring_dbt_functions(module)

    lines: List[str] = docstring_dbt_functions + dbt_function_calls

    # Jinja-fy the calls
    return "\n".join(map(lambda s: "{{ " + s.strip() + " }}", lines))
