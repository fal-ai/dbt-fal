import ast
from typing import List, cast
from pathlib import Path

from faldbt.parse import load_dbt_project_contract
from fal.cli.model_generator.deps_generator import generate_dbt_dependencies

SQL_MODEL_TEMPLATE = """
{{ config(materialized='ephemeral') }}
/*
FAL_GENERATED

Script dependencies:

__deps__

*/

SELECT * FROM {{ target.schema }}.{{ model.name }}
"""


def generate_python_dbt_models(project_dir: str):
    project_contract = load_dbt_project_contract(project_dir)
    project_path = Path(project_dir)
    model_paths = map(
        project_path.joinpath, cast(List[str], project_contract.model_paths)
    )
    python_paths = _find_python_files(list(model_paths))

    for py_path in python_paths:
        sql_path = py_path.with_suffix(".sql")
        _check_path_safe_to_write(sql_path, py_path)

        with open(py_path) as file:
            module = ast.parse(file.read(), str(py_path), "exec")

        dbt_deps: str = generate_dbt_dependencies(module)
        sql_contents = SQL_MODEL_TEMPLATE.replace("__deps__", dbt_deps)

        with open(sql_path, "w") as file:
            file.write(sql_contents)

    return dict([(path.stem, path) for path in python_paths])


def _check_path_safe_to_write(sql_path: Path, py_path: Path):
    if sql_path.exists():
        with open(sql_path, "r") as file:
            contents = file.read()
            if "FAL_GENERATED" not in contents:
                raise RuntimeError(
                    f"File '{sql_path}' not generated by fal would be overwritten by generated model of '{py_path}'. Please rename or remove."
                )


def _find_python_files(model_paths: List[Path]) -> List[Path]:
    paths_lists = map(lambda p: list(p.rglob("*.py")), model_paths)
    flat_paths = sum(paths_lists, [])
    flat_files = filter(lambda p: p.is_file(), flat_paths)
    return list(flat_files)
